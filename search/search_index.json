{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"ACRCloud Ingest Service","text":"<p>Takes care of ingesting daily ACRCloud Broadcast Monitoring data dumps.</p>"},{"location":"#usage","title":"Usage","text":"<p>Run the container to see all available configuration options and their corresponding environment variables.</p> <pre><code>podman run --rm ghcr.io/radiorabe/acringest:latest acringest --help\n</code></pre>"},{"location":"#development","title":"Development","text":"<pre><code>python -mvenv venv\n. venv/bin/activate\n\npip install poetry\npoetry install\n\npytest\n</code></pre>"},{"location":"#release-management","title":"Release Management","text":"<p>The CI/CD setup uses semantic commit messages following the conventional commits standard. The workflow is based on the RaBe shared actions and uses go-semantic-commit to create new releases.</p> <p>The commit message should be structured as follows:</p> <pre><code>&lt;type&gt;[optional scope]: &lt;description&gt;\n\n[optional body]\n\n[optional footer(s)]\n</code></pre> <p>The commit contains the following structural elements, to communicate intent to the consumers of your library:</p> <ol> <li>fix: a commit of the type <code>fix</code> patches gets released with a PATCH version bump</li> <li>feat: a commit of the type <code>feat</code> gets released as a MINOR version bump</li> <li>BREAKING CHANGE: a commit that has a footer <code>BREAKING CHANGE:</code> gets released as a MAJOR version bump</li> <li>types other than <code>fix:</code> and <code>feat:</code> are allowed and don't trigger a release</li> </ol> <p>If a commit does not contain a conventional commit style message you can fix it during the squash and merge operation on the PR.</p>"},{"location":"#build-process","title":"Build Process","text":"<p>The CI/CD setup uses Docker build-push Action  to publish container images. The workflow is based on the RaBe shared actions.</p>"},{"location":"#license","title":"License","text":"<p>This application is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, version 3 of the License.</p>"},{"location":"#copyright","title":"Copyright","text":"<p>Copyright (c) 2023 Radio Bern RaBe</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>acringest</li> </ul>"},{"location":"reference/acringest/","title":"acringest","text":"<p>Extract data from loaded ACRCloud records.</p>"},{"location":"reference/acringest/#acringest.app","title":"<code>app(bootstrap_servers, security_protocol, tls_cafile, tls_certfile, tls_keyfile, consumer_topic, consumer_group, consumer_auto_offset_reset, minio_url, minio_access_key, minio_secret_key, minio_bucket_raw, minio_bucket_music, minio_secure, minio_cert_reqs, minio_ca_certs)</code>","text":"<p>Consume MinIO CloudEvents and create deduped and historized objects.</p> Source code in <code>acringest.py</code> <pre><code>def app(  # noqa: PLR0912,PLR0913,C901\n    bootstrap_servers: list[str],\n    security_protocol: str,\n    tls_cafile: str,\n    tls_certfile: str,\n    tls_keyfile: str,\n    consumer_topic: str,\n    consumer_group: str,\n    consumer_auto_offset_reset: str,\n    minio_url: str,\n    minio_access_key: str,\n    minio_secret_key: str,\n    minio_bucket_raw: str,\n    minio_bucket_music: str,\n    minio_secure: bool,  # noqa: FBT001\n    minio_cert_reqs: str,\n    minio_ca_certs: str,\n) -&gt; None:\n    \"\"\"Consume MinIO CloudEvents and create deduped and historized objects.\"\"\"\n    consumer = KafkaConsumer(\n        consumer_topic,\n        bootstrap_servers=bootstrap_servers,\n        security_protocol=security_protocol,\n        group_id=consumer_group,\n        auto_offset_reset=consumer_auto_offset_reset,\n        ssl_cafile=tls_cafile,\n        ssl_certfile=tls_certfile,\n        ssl_keyfile=tls_keyfile,\n    )\n\n    def on_sigint(*_: Any) -&gt; NoReturn:  # noqa: ANN401 # pragma: no cover\n        consumer.close()\n        sys.exit(0)\n\n    signal.signal(signal.SIGINT, on_sigint)\n\n    mc = Minio(\n        minio_url,\n        minio_access_key,\n        minio_secret_key,\n        secure=minio_secure,\n        http_client=urllib3.PoolManager(\n            cert_reqs=minio_cert_reqs,\n            ca_certs=minio_ca_certs,\n        ),\n    )\n    for bucket in [minio_bucket_raw, minio_bucket_music]:\n        if not mc.bucket_exists(bucket):  # pragma: no cover\n            mc.make_bucket(bucket)\n\n    for msg in consumer:\n        headers: list[tuple[str, bytes]] = msg.headers if msg.headers else []\n        ce: CloudEvent = from_structured(\n            message=KafkaMessage(\n                key=msg.key,\n                value=msg.value,\n                headers={h[0]: h[1] for h in headers},\n            ),\n        )\n        if (\n            ce[\"source\"] == \"minio:s3..acrcloud.raw\"\n            and ce[\"type\"] == \"com.amazonaws.s3.s3:ObjectCreated:Put\"\n        ):\n            bucket = ce.data.get(\"s3\", {}).get(\"bucket\", {}).get(\"name\")\n            name = ce.data.get(\"s3\", {}).get(\"object\", {}).get(\"key\")\n            obj = mc.get_object(bucket, name)\n            for data in obj.json():\n                for music in data.get(\"metadata\", {}).get(\"music\", []):\n                    acrid = music.get(\"acrid\")\n                    for key in list(music.keys()):\n                        if key not in _ACR_EXPECTED_KEYS:  # pragma: no cover\n                            logger.error(\"Unexpected key %s in acr results\", key)\n                    for to_del in _ACR_IGNORED_KEYS:\n                        if to_del in music:\n                            del music[to_del]\n                    minio_data = None\n                    try:\n                        minio_data = mc.get_object(minio_bucket_music, acrid).json()\n                    except S3Error as ex:  # pragma: no cover\n                        if ex.code == \"NoSuchKey\":\n                            put_data(mc, minio_bucket_music, acrid, json.dumps(music))\n                            minio_data = music\n                    changes = diff(minio_data, music)\n                    if changes:\n                        put_data(mc, minio_bucket_music, acrid, json.dumps(music))\n                        logger.info(\"Applied changes to acrid=%s: %s\", acrid, changes)\n</code></pre>"},{"location":"reference/acringest/#acringest.main","title":"<code>main()</code>","text":"<p>Run main.</p> Source code in <code>acringest.py</code> <pre><code>def main() -&gt; None:  # pragma: no cover\n    \"\"\"Run main.\"\"\"\n    parser = ArgumentParser(__name__)\n    parser.add(\n        \"--kafka-bootstrap-servers\",\n        required=True,\n        env_var=\"KAFKA_BOOTSTRAP_SERVERS\",\n    )\n    parser.add(\n        \"--kafka-security-protocol\",\n        default=\"PLAINTEXT\",\n        env_var=\"KAFKA_SECURITY_PROTOCOL\",\n    )\n    parser.add(\n        \"--kafka-tls-cafile\",\n        default=None,\n        env_var=\"KAFKA_TLS_CAFILE\",\n    )\n    parser.add(\n        \"--kafka-tls-certfile\",\n        default=None,\n        env_var=\"KAFKA_TLS_CERTFILE\",\n    )\n    parser.add(\n        \"--kafka-tls-keyfile\",\n        default=None,\n        env_var=\"KAFKA_TLS_KEYFILE\",\n    )\n    parser.add(\n        \"--kafka-consumer-topic\",\n        default=\"cloudevents\",\n        env_var=\"KAFKA_CONSUMER_TOPIC\",\n    )\n    parser.add(\n        \"--kafka-consumer-group\",\n        default=__name__,\n        env_var=\"KAFKA_CONSUMER_GROUP\",\n    )\n    parser.add(\n        \"--kafka-consumer-auto-offset-reset\",\n        default=\"latest\",\n        env_var=\"KAFKA_CONSUMER_AUTO_OFFSET_RESET\",\n    )\n    parser.add(\n        \"--minio-url\",\n        default=\"minio.service.int.rabe.ch:9000\",\n        env_var=\"MINIO_HOST\",\n        help=\"MinIO Hostname\",\n    )\n    parser.add(\n        \"--minio-secure\",\n        default=True,\n        env_var=\"MINIO_SECURE\",\n        help=\"MinIO Secure param\",\n    )\n    parser.add(\n        \"--minio-cert-reqs\",\n        default=\"CERT_REQUIRED\",\n        env_var=\"MINIO_CERT_REQS\",\n        help=\"cert_reqs for urlib3.PoolManager used by MinIO\",\n    )\n    parser.add(\n        \"--minio-ca-certs\",\n        default=\"/etc/pki/ca-trust/extracted/openssl/ca-bundle.trust.crt\",\n        env_var=\"MINIO_CA_CERTS\",\n        help=\"ca_certs for urlib3.PoolManager used by MinIO\",\n    )\n    parser.add(\n        \"--minio-bucket-raw\",\n        default=\"acrcloud.raw\",\n        env_var=\"MINIO_BUCKET_RAW\",\n        help=\"MinIO Bucket with raw ACRCloud data\",\n    )\n    parser.add(\n        \"--minio-bucket-music\",\n        default=\"acrcloud.music\",\n        env_var=\"MINIO_BUCKET_MUSIC\",\n        help=\"MinIO Bucket with music ACRCloud data\",\n    )\n    parser.add(\n        \"--minio-access-key\",\n        default=None,\n        env_var=\"MINIO_ACCESS_KEY\",\n        help=\"MinIO Access Key\",\n    )\n    parser.add(\n        \"--minio-secret-key\",\n        default=None,\n        env_var=\"MINIO_SECRET_KEY\",\n        help=\"MinIO Secret Key\",\n    )\n    parser.add(\n        \"--quiet\",\n        \"-q\",\n        default=False,\n        action=\"store_true\",\n        env_var=\"ACRINGEST_QUIET\",\n    )\n    parser.add(\n        \"--debug\",\n        \"-d\",\n        default=False,\n        action=\"store_true\",\n        env_var=\"ACRINGEST_DEBUG\",\n    )\n\n    options = parser.parse_args()\n\n    if not options.quiet:\n        logging.basicConfig(level=logging.INFO)\n    if options.debug:\n        logging.basicConfig(level=logging.DEBUG)\n    logger.info(\"Starting %s\", __name__)\n\n    app(\n        bootstrap_servers=options.kafka_bootstrap_servers,\n        security_protocol=options.kafka_security_protocol,\n        tls_cafile=options.kafka_tls_cafile,\n        tls_certfile=options.kafka_tls_certfile,\n        tls_keyfile=options.kafka_tls_keyfile,\n        consumer_topic=options.kafka_consumer_topic,\n        consumer_group=options.kafka_consumer_group,\n        consumer_auto_offset_reset=options.kafka_consumer_auto_offset_reset,\n        minio_url=options.minio_url,\n        minio_access_key=options.minio_access_key,\n        minio_secret_key=options.minio_secret_key,\n        minio_bucket_raw=options.minio_bucket_raw,\n        minio_bucket_music=options.minio_bucket_music,\n        minio_secure=options.minio_secure,\n        minio_cert_reqs=options.minio_cert_reqs,\n        minio_ca_certs=options.minio_ca_certs,\n    )\n</code></pre>"},{"location":"reference/acringest/#acringest.put_data","title":"<code>put_data(mc, bucket, acrid, data)</code>","text":"<p>Put data to MinIO.</p> Source code in <code>acringest.py</code> <pre><code>def put_data(mc: Minio, bucket: str, acrid: str, data: str) -&gt; None:\n    \"\"\"Put data to MinIO.\"\"\"\n    _as_bytes = data.encode(\"utf-8\")\n    mc.put_object(\n        bucket,\n        acrid,\n        BytesIO(_as_bytes),\n        length=len(_as_bytes),\n        content_type=\"application/json\",\n    )\n</code></pre>"}]}